Project hygiene (quick wins)

Split into files: attacks.hpp/.cpp, position.hpp/.cpp, uci.cpp, main.cpp.

Add a README.md with build/run instructions and perft results.

Add clang-format and run it once.

Add a -DNDEBUG Release config in CMake (or default to Release).

FEN + “position … moves …”

Implement FEN parser (set pieces, side, castling flags, ep square).

Extend position command to accept:
position fen <FEN> [moves ...] and position startpos moves e2e4 e7e5 ….

Add a tiny parseMove() (UCI coordinate like e2e4, with promotion).

Search that plays chess

Add material-only eval (already easy).

Implement negamax + alpha–beta with:

move ordering: captures first (MVV/LVA-ish), killer moves, history table.

iterative deepening: depth 1..N; keep best move each iteration.

principal variation (PV) storage + UCI “info … pv …”.

Add UCI: go depth N → print bestmove ….

(Optional) quiescence search on captures to reduce horizon blunders.

Speed features

Transposition table (Zobrist hash + TT buckets, store {key, depth, score, flag, move}).

Zobrist hashing for: pieces, side to move, castling rights, EP file.

TT move ordering: probe TT first; use stored best move as first child.

Late move reductions (LMR) & null-move pruning (after TT is solid).

UCI polish

Print info depth X nodes N time T nps … pv … each iteration.

Add options: Hash, Threads (start with 1), Move Overhead.

Support stop/isready correctly during search (search loop checks a flag).

GUI integration

Download Arena or CuteChess.

Add engine: point to your ChessEngine.exe.

Play vs itself or your favorite engine; set fixed depth first.

Testing

Keep perft regression tests (1..6 startpos, a few tricky FENs: EP, castling, promotions).

Add unit tests for FEN ↔ board round-trip.

Run a small gauntlet in CuteChess: -rounds 50 -games 2 -each tc=40/5.

Optimization options (later)

Replace ray-walkers with magic bitboards (fast sliding attacks).

If your CPU supports BMI2, try PEXT tables.

Bit-pack moves into 32 bits; use SoA bitboards; profile hotspots.